"""

Usage:
  fedora.py fetch vuln_reports
  fedora.py fetch bugs
  fedora.py fetch advisories
  
Options:
  -h --help     Show this screen.
  
"""

from docopt import docopt
import utils.tool as tool
import os, pandas, csv, re
from datetime import datetime
import fedora.bugzilla_helper as bugzilla_helper
import fedora.pkg_helper as pkg_helper
import requests
import gzip
import mailbox
from dateutil import parser

def fetch_vuln_reports(args):
    if not os.path.exists('cve_info_from_nvd.csv'):
        print('ERRPR! The CVE file does not exist. Please download cve records ...')
        return

    projects = pandas.read_csv("cve_info_from_nvd.csv", index_col=None, header=0, delimiter=';')
    fieldnames = ['cve_id','id' ,'resolution', 'status','creator', 'creation_time', 'priority', 'severity','last_change_time', 'summary', 'ref_url', 'cf_last_closed']
    with open('fedora_vuln_report.csv', 'w+', newline='\n', encoding='utf8') as csvfile:
        writer = csv.DictWriter(csvfile, fieldnames=fieldnames, delimiter=';')
        writer.writeheader()

        for index, row in projects.iterrows():
            cve_id = row['id']
            # cve_id = "CVE-2006-3581"
            ob = bugzilla_helper.fetch_bug_from_api_by_id("https://bugzilla.redhat.com/",cve_id)
            if 'id' not in ob:
              continue
            ob['cve_id'] = cve_id
            # print(ob) 
            
            writer.writerow(ob)
            
            # if index > 10:
            #     break
            if index > 0 and index % 100 == 0:
                csvfile.flush()
                print(datetime.now(), index, " lines passed ...")
    csvfile.close()


def fetch_bugs(args):
    field_names = ['id','product','severity','status','creator','assigned_to','component','summary','creation_time','last_change_time','cf_last_closed', 'version','priority','resolution','blocks']

    if not os.path.exists('fedora_comments/'):
        os.mkdir('fedora_comments')

    bugzilla_helper.fetch_bugs('fedora_bugs.csv', field_names)

    bugs = pandas.read_csv('fedora_bugs.csv', index_col=None, header=0, delimiter=';')
    bugs = bugs[pandas.notnull(bugs['blocks'])]
    dt_cvd_ids = pandas.read_csv('fedora_vuln_report.csv', index_col=None, header=0, delimiter=';')

    fieldnames = ['cve_id', 'component', 'dist_id']
    with open('fedora_cve_map_ids.csv', 'w+', newline='\n', encoding='utf8') as csvfile:
        writer = csv.DictWriter(csvfile, fieldnames=fieldnames, delimiter=';')
        writer.writeheader()

        for index, row in dt_cvd_ids.iterrows():
            cve_ids = tool.get_cve_id(row['summary'])
            if len(cve_ids)>0:
                dt_cvd_ids.at[index, 'cve_id'] = '#'.join(cve_ids)
            
            dt = bugs[bugs['blocks'].str.contains(str(row['id']))]
            # dt = bugs[bugs.blocks.str.contains(row['id'])]
            if len(dt.index)>0:
                for index2, row2 in dt.iterrows():
                    # print(row2['id'], cve_ids[0],row['id'])
                    for cve_id in cve_ids:
                        ob = {}
                        ob['dist_id'] = row2['id']
                        ob['cve_id'] = cve_id
                        ob['component'] = row2['component']
                        writer.writerow(ob)
            else:
                for cve_id in cve_ids:
                    ob = {}
                    ob['dist_id'] = ''
                    ob['cve_id'] = cve_id
                    ob['component'] = ''
                    writer.writerow(ob)

            if index % 1000 == 0:
                csvfile.flush()
                print(index ," lines passed ", datetime.now())
                # break
    csvfile.close()

# def fetch_pkgs(args):
#     if not os.path.exists('fedora_bugs.csv'):
#         print('ERRPR! The bug file does not exist. Please download bugs ...')
#         return

#     projs = pandas.read_csv('fedora_bugs.csv', index_col=None, header=0, delimiter=';')
#     arr_pkg = pandas.unique(projs[['component']].values.ravel())
    
#     field_names = ['name', 'pack_desc', 'upstream_url']
#     with open('fedora_pkgs.csv', 'w+', newline='\n') as csvfile:
#         writer = csv.DictWriter(csvfile, fieldnames=field_names, delimiter=';')
#         writer.writeheader()

#         # print(len(arr_pkg))
#         for pkg in arr_pkg:
#             is_unknown = pkg_helper.is_unknown_pkg(pkg)
            
#             if is_unknown:
#                 continue
            
#             raw_hide_ob = pkg_helper.fetch_pkg_rawhide_info(pkg)
#             newob = {}
#             newob['name'] = pkg
#             src_ob = pkg_helper.fetch_pkg_info(pkg)
#             if src_ob == None and raw_hide_ob == None:
#                 continue
#             newob['pack_desc'] = src_ob['description'].replace("\r","",100).replace("\n","",100)
#             if raw_hide_ob != None:
#                 newob['upstream_url'] = raw_hide_ob['url']
                
#             writer.writerow(newob)
            
#         csvfile.close()

def fetch_advisories(args):
    mail_folder = "fedora_mail/"
    if not os.path.exists(mail_folder):
        os.mkdir(mail_folder)
    
    for ym in tool.month_year_iter(1, 2005, 1, 2020):
        print(ym[0], ym[1])

        sdate = str(ym[0]) +"-"+ format(ym[1], '02d') 
        edate = str(ym[0]) +"-"+ format(ym[1]+1, '02d') 
        if ym[1] == 12:
            edate = str(ym[0]+1) +"-"+ format(1, '02d') 
        # print(sdate, edate)
        url = "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/export/package-announce@lists.fedoraproject.org-"+sdate+".mbox.gz?start="+sdate+"-01&end="+edate+"-01" 
        # print(url)

        fname = sdate+".mbox.gz"
        with open(mail_folder+fname, "wb") as rf:
            r = requests.get(url)
            rf.write(r.content)
        rf.close()

        with open(mail_folder+fname, 'rb') as inf, open(mail_folder+fname.replace(".gz",""), 'w', encoding='utf8') as tof:
            decom_str = gzip.decompress(inf.read()).decode('utf-8')
            tof.write(decom_str)
        tof.close()
        inf.close()

        os.remove(mail_folder+fname)

    fieldnames = ['fsa_id','cve_id','publish_date', 'dist_ids']
    with open("fedora_advisories.csv", 'w+', newline='\n', encoding='utf8') as csvfile:
        writer = csv.DictWriter(csvfile, fieldnames=fieldnames, delimiter=';')
        writer.writeheader()
        for ff in os.listdir(mail_folder):
            if ff.endswith(".mbox"):
                print(os.path.join(mail_folder, ff))
                mbox = mailbox.mbox(os.path.join(mail_folder, ff))
                for message in mbox:
                    if "[SECURITY]" in message['subject']:
                        # print(message['subject'])
                        mail_date = parser.parse(message['Date'])
                        content = getbody(message).decode("utf-8")
                        
                        cve_ids = tool.get_cve_id(content)
                        cve_ids = list(dict.fromkeys(cve_ids))

                        bug_ids = extract_bug_ids(content)

                        if len(cve_ids) == 0 and len(bug_ids) == 0:
                            continue
                        
                        fsa_id, publish_date = extract_fsa_id_and_publish_date(content)
                        # print(fsa_id, publish_date, cve_ids, bug_ids)
                        
                        if publish_date is None:
                            # print(mail_date, publish_date)
                            publish_date = mail_date
                        for rr in cve_ids:
                            ob = {}
                            ob['cve_id'] = rr
                            ob['fsa_id'] = fsa_id
                            ob['publish_date'] = publish_date
                            ob['dist_ids'] = '#'.join(bug_ids)
                            writer.writerow(ob)
                        # break
            # break
            os.remove(mail_folder+ff)

    csvfile.close()

    

def getbody(message): #getting plain text 'email body'
    body = None
    if message.is_multipart():
        for part in message.walk():
            if part.is_multipart():
                for subpart in part.walk():
                    if subpart.get_content_type() == 'text/plain':
                        body = subpart.get_payload(decode=True)
            elif part.get_content_type() == 'text/plain':
                body = part.get_payload(decode=True)
    elif message.get_content_type() == 'text/plain':
        body = message.get_payload(decode=True)
    return body

def extract_bug_ids(text):
    bl_ref_section = False
    bug_ids = []

    for line in text.split('\n'):
        if "References:" in line:
            bl_ref_section = True
        if bl_ref_section and line.startswith("----------------------"):
            bl_ref_section = False
            break

        if bl_ref_section:
            str_re = "Bug #\d{4,7} -"
            ids = re.findall(str_re, line)
            # print(line)
            for ii in ids:
                bid = ii.replace("Bug", "").replace("#", "").replace("-", "").strip()

                if bid not in bug_ids:
                    bug_ids.append(bid)
    
    return bug_ids
        
def extract_fsa_id_and_publish_date(text):
    cnt = 0
    bl_meta = False
    fsa_id = ""
    publish_date = ""
    for line in text.split('\n'):
        if cnt == 1:
            fsa_id = line  
        elif cnt == 2:
            # print(line)
            if line.startswith("----------------") or line.startswith("None"):
                publish_date = None
            else:
                publish_date = parser.parse(line.strip())
            break

        if "Fedora Update Notification" in line:
            bl_meta = True
        if bl_meta:
            cnt += 1
        
    
    # print(fsa_id, publish_date)
    return fsa_id, publish_date


if __name__== "__main__":
    
    args = docopt(__doc__)

    if bool(args['fetch']) and bool(args['bugs']):
        fetch_bugs(args)
    elif bool(args["fetch"]) and bool(args["vuln_reports"]):
        fetch_vuln_reports(args)
    elif bool(args["fetch"]) and bool(args["advisories"]):
        fetch_advisories(args)